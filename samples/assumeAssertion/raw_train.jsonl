["79e1256a-5e2d-4570-8551-b1c6226e27b7","testCorrectlyCalculatesLargestProductOfLength0ForEmptyStringToSearch","{\n    final LargestSeriesProductCalculator calculator = new LargestSeriesProductCalculator(\"\");\n    final long expectedProduct = 1;\n    final long actualProduct = calculator.calculateLargestProductForSeriesLength(0);\n    ???;\n}",[],"public long calculateLargestProductForSeriesLength(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"Series length must be non-negative.\");\n    return IntStream.rangeClosed(0, str.length() - n).mapToObj(index -> str.substring(index, index + n)).mapToLong(s -> s.chars().map(Character::getNumericValue).mapToLong(Long::valueOf).reduce(1, (k, l) -> k * l)).max().orElseThrow(() -> new IllegalArgumentException(\"Series length must be less than or equal to the length of the string to search.\"));\n}",[],"assertEquals(expectedProduct, actualProduct);"]
["e58ac343-9edf-47ca-acbb-8ad3dfb5047b","testCorrectlyCalculatesLargestProductOfLength0ForNonEmptyStringToSearch","{\n    final LargestSeriesProductCalculator calculator = new LargestSeriesProductCalculator(\"123\");\n    final long expectedProduct = 1;\n    final long actualProduct = calculator.calculateLargestProductForSeriesLength(0);\n    ???;\n}",[],"public long calculateLargestProductForSeriesLength(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"Series length must be non-negative.\");\n    return IntStream.rangeClosed(0, str.length() - n).mapToObj(index -> str.substring(index, index + n)).mapToLong(s -> s.chars().map(Character::getNumericValue).mapToLong(Long::valueOf).reduce(1, (k, l) -> k * l)).max().orElseThrow(() -> new IllegalArgumentException(\"Series length must be less than or equal to the length of the string to search.\"));\n}",[],"assertEquals(expectedProduct, actualProduct);"]
["2a8047ac-b596-43f2-bb91-2fd4c7cd59b4","testParEmpty","{\n    List<Task<Integer>> tasks = Collections.emptyList();\n    ParTask<Integer> task = Task.par(tasks);\n    runAndWait(\"TestTaskFactoryMethods.testParEmpty\", task);\n    ???;\n}",[],"public static <T> ParTask<T> par(final Iterable<? extends Task<? extends T>> tasks) {\n    return tasks.iterator().hasNext() ? new ParTaskImpl<T>(\"par\", tasks) : new ParTaskImpl<T>(\"par\");\n}",[],"assertEquals(task.get().stream().mapToInt(Integer::intValue).sum(), 0);\nassertEquals(countTasks(task.getTrace()), 1);"]
["d7571ef7-a133-4b32-b315-71e766384931","testParseEmpty","{\n    List<String> commands = new ArrayList<>();\n    List<Movable> mowers = mowerParser.parse(commands);\n    ???;\n}",[],"public List<Movable> parse(List<String> commands) {\n    List<Movable> mowers = new ArrayList<>();\n    if (CollectionUtils.isNotEmpty(commands) && commands.size() >= 3) {\n        List<Coordinate> coordinates = new ArrayList<>();\n        List<String> instructions = new ArrayList<>();\n        // Ignore first command (grass)\n        for (String command : commands.subList(1, commands.size())) {\n            if (Pattern.matches(\"^[0-9] [0-9] [neswNESW]$\", command)) {\n                String[] coordinate = command.split(\" \");\n                coordinates.add(new CoordinateImpl(Integer.parseInt(coordinate[0]), Integer.parseInt(coordinate[1]), Orientation.valueOf(coordinate[2].toUpperCase())));\n            } else {\n                // If pattern not matches then this is an instruction\n                instructions.add(command);\n            }\n        }\n        // Create mowers\n        for (int i = 0; i < coordinates.size(); i++) {\n            if (i < instructions.size()) {\n                mowers.add(new Mower(coordinates.get(i), instructions.get(i)));\n            }\n        }\n    }\n    return mowers;\n}",[],"assertThat(mowers.isEmpty(), equalTo(true));"]
["fb0678c7-cfc6-4c61-b9d2-fa34f7d59c48","testParseEmptyList","{\n    Optional<Field> grass = grassParser.parse(new ArrayList<String>());\n    ???;\n}",[],"public Optional<Field> parse(List<String> commands) {\n    Field field = null;\n    if (CollectionUtils.isNotEmpty(commands)) {\n        String command = commands.get(0);\n        if (Pattern.matches(\"^[0-9] [0-9]$\", command)) {\n            String[] size = command.split(\" \");\n            field = new Grass(Integer.parseInt(size[0]), Integer.parseInt(size[1]));\n        }\n    }\n    return Optional.ofNullable(field);\n}",[],"assertThat(grass.isPresent(), equalTo(false));"]
["d790c4a5-2274-47b0-97df-954fe931d314","testGetNonExistingKeyReturnEmptyMap","{\n    valueStore = PropogatedValueStore.newInstance();\n    node = EntityNodeImpl.newInstance(Integer.class);\n    Map<Field, Object> result = valueStore.get(node);\n    ???;\n}",[],"public Map<K, V> get(T t) {\n    return getValueOrCreateIfNotExist(t);\n}",["private Map<K, V> getValueOrCreateIfNotExist(T key) {\n    return MapUtil.getOrCreateMap(this.dataStore, key);\n}"],"assertThat(result, is(not(nullValue())));\nassertThat(result.size(), is(0));"]
["2e5f01ef-3b1f-4e4f-aa2b-619369a8159b","testSolveForClassWithEmptyDepsReturnsOnlyRoot","{\n    CommandNodes commands = ns(n(ClassA.class));\n    CreationPlan result = SolverImpl.newInstance(new DepsBuilder().build()).solveFor(commands);\n    ???;\n}",[],"@Override\npublic <E> CreationPlan solveFor(final CommandNodes commands) {\n    ActionGraph actionGraph = createActionGraph(commands);\n    return CreationPlan.newInstance(actionGraph);\n}",[],"assertThat(result.getActionGraph().getAllNodes().size(), is(1));\nassertEquals(result.getActionGraph().getAllNodes().get(0).getEntityClass(), ClassA.class);"]
["b96b8e66-db58-4fd7-8ecb-9447c037591a","testEmptyArray","{\n    List<Value> array = createParser(\"[]\").parse().getArray();\n    ???;\n}",["private Parser createParser(String s) {\n    input = new StringReader(s);\n    return new Parser(input);\n}"],"@SuppressWarnings(\"unchecked\")\npublic List<Value> getArray() {\n    return (List<Value>) value;\n}",[],"assertEquals(0, array.size());"]
["22d1a715-a5ae-4771-bf70-1470796b9508","testObjectWithEmptyLists","{\n    Map<String, Value> object = createParser(\"{ \\\"foo\\\": [], \\\"baz\\\": []}\").parse().getObject();\n    ???;\n}",["private Parser createParser(String s) {\n    input = new StringReader(s);\n    return new Parser(input);\n}"],"@SuppressWarnings(\"unchecked\")\npublic Map<String, Value> getObject() {\n    return (Map<String, Value>) value;\n}",[],"assertTrue(object.get(\"foo\").getArray().isEmpty());\nassertTrue(object.get(\"baz\").getArray().isEmpty());"]
["142e505a-1fa2-4267-9e3a-ae060d8317fa","shouldMapEmptyList","{\n    this.mapper = Mapping.from(A.class).to(A.class).mapper();\n    List<A> list = mapper.map(Collections.emptyList());\n    ???;\n}",[],"public List<D> map(List<? extends S> source) {\n    return (List<D>) _mapCollection(source);\n}",["@SuppressWarnings(\"unchecked\")\nprivate Collection<D> _mapCollection(Collection<? extends S> source) {\n    return (Collection<D>) source.stream().map(this::map).collect(getCollector(source));\n}"],"assertTrue(list.isEmpty());"]
["b2b70a17-c3b2-4c13-9d84-2075a3d0e043","shouldMapEmptySet","{\n    this.mapper = Mapping.from(A.class).to(A.class).mapper();\n    Set<A> list = mapper.map(Collections.emptySet());\n    ???;\n}",[],"public Set<D> map(Set<? extends S> source) {\n    return (Set<D>) _mapCollection(source);\n}",["@SuppressWarnings(\"unchecked\")\nprivate Collection<D> _mapCollection(Collection<? extends S> source) {\n    return (Collection<D>) source.stream().map(this::map).collect(getCollector(source));\n}"],"assertTrue(list.isEmpty());"]
["029c677b-65f4-4d14-a657-da5ebbf0d177","test_filterTable_emptyTable","{\n    LinkedHashMap<String, List<ResourceInfoRowDAO>> toBeFilteredTable = new LinkedHashMap<String, List<ResourceInfoRowDAO>>();\n    LinkedHashMap<String, List<ResourceInfoRowDAO>> expectedTable = new LinkedHashMap<String, List<ResourceInfoRowDAO>>();\n    TableDAO table = new TableDAO(toBeFilteredTable);\n    table.filterTable();\n    ???;\n}",[],"public void filterTable() {\n    if (table.isEmpty())\n        return;\n    String key = table.keySet().iterator().next();\n    table.remove(key);\n    HashMap<String, List<ResourceInfoRowDAO>> rememberDeletionMap = new HashMap<String, List<ResourceInfoRowDAO>>();\n    for (String version : table.keySet()) {\n        List<ResourceInfoRowDAO> listOfdeleteTargetResources = new ArrayList<ResourceInfoRowDAO>();\n        for (ResourceInfoRowDAO resourceMap : table.get(version)) {\n            if (!isResourceRowRelevant(resourceMap)) {\n                listOfdeleteTargetResources.add(resourceMap);\n            }\n        }\n        rememberDeletionMap.put(version, listOfdeleteTargetResources);\n    }\n    for (String version : rememberDeletionMap.keySet()) {\n        for (ResourceInfoRowDAO resource : rememberDeletionMap.get(version)) {\n            table.get(version).remove(resource);\n        }\n    }\n}",[],"Assert.assertEquals(expectedTable, toBeFilteredTable);"]
